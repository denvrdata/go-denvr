// Package applications provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package applications

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/oapi-codegen/runtime"

	// "github.com/hashicorp/go-retryablehttp"

	"github.com/denvrdata/go-denvr/config"
	"github.com/denvrdata/go-denvr/response"
)

// ApplicationsApiApplicationConfig defines model for ApplicationsApiApplicationConfig.
type ApplicationsApiApplicationConfig struct {
	Clusters                *[]string `json:"clusters"`
	Description             *string   `json:"description"`
	DirectAttachedStorageGb *int32    `json:"directAttachedStorageGb"`
	GpuBrand                *string   `json:"gpuBrand"`
	GpuCount                *int32    `json:"gpuCount"`
	GpuName                 *string   `json:"gpuName"`
	GpuType                 *string   `json:"gpuType"`
	MemoryGb                *int64    `json:"memoryGb"`
	Name                    *string   `json:"name"`
	PricePerHour            *float64  `json:"pricePerHour"`
	VcpusCount              *int32    `json:"vcpusCount"`
}

// ApplicationsApiApplicationConfigAvailability defines model for ApplicationsApiApplicationConfigAvailability.
type ApplicationsApiApplicationConfigAvailability struct {
	Available     *bool    `json:"available"`
	Cluster       *string  `json:"cluster"`
	Configuration *string  `json:"configuration"`
	Count         *int32   `json:"count"`
	MaxCount      *int32   `json:"maxCount"`
	Price         *float64 `json:"price"`
	Rpool         *string  `json:"rpool"`
}

// ApplicationsApiCatalogItem defines model for ApplicationsApiCatalogItem.
type ApplicationsApiCatalogItem struct {
	ApplicationSourceDetailsUrl *string                              `json:"applicationSourceDetailsUrl"`
	Name                        *string                              `json:"name"`
	Versions                    *[]ApplicationsApiCatalogItemVersion `json:"versions"`
}

// ApplicationsApiCatalogItemVersion defines model for ApplicationsApiCatalogItemVersion.
type ApplicationsApiCatalogItemVersion struct {
	ImageLastPushDate *time.Time `json:"imageLastPushDate"`
	ImageUrl          *string    `json:"imageUrl"`
	LaunchType        *string    `json:"launchType"`
	Name              *string    `json:"name"`
	Platform          *string    `json:"platform"`
	ReleaseNotesUrl   *string    `json:"releaseNotesUrl"`
}

// ApplicationsApiCommandRequest defines model for ApplicationsApiCommandRequest.
type ApplicationsApiCommandRequest struct {
	// Cluster The cluster you're operating on
	Cluster string `json:"cluster"`

	// Id The application name
	Id string `json:"id"`
}

// ApplicationsApiCommandResponse defines model for ApplicationsApiCommandResponse.
type ApplicationsApiCommandResponse struct {
	// Cluster The cluster you're operating on
	Cluster string `json:"cluster"`

	// Id The application name
	Id string `json:"id"`
}

// ApplicationsApiCreateRequest defines model for ApplicationsApiCreateRequest.
type ApplicationsApiCreateRequest struct {
	// ApplicationCatalogItemName The name of the application catalog item.
	ApplicationCatalogItemName string `json:"applicationCatalogItemName"`

	// ApplicationCatalogItemVersion The version name of the application catalog item.
	ApplicationCatalogItemVersion string `json:"applicationCatalogItemVersion"`

	// Cluster The cluster you're operating on
	Cluster string `json:"cluster"`

	// HardwarePackageName The name or unique identifier of the application hardware configuration to use for the application.
	HardwarePackageName string `json:"hardwarePackageName"`

	// JupyterToken An authentication token for accessing Jupyter Notebook enabled applications
	JupyterToken *string `json:"jupyterToken"`

	// Name The application name
	Name string `json:"name"`

	// PersistDirectAttachedStorage Indicates whether to persist direct attached storage (if resource pool is reserved)
	PersistDirectAttachedStorage *bool `json:"persistDirectAttachedStorage,omitempty"`

	// PersonalSharedStorage Enable personal shared storage for the application
	PersonalSharedStorage *bool `json:"personalSharedStorage,omitempty"`

	// ResourcePool The resource pool to use for the application
	ResourcePool *string `json:"resourcePool"`

	// SshKeys The SSH keys for accessing the application
	SshKeys *[]string `json:"sshKeys"`

	// TenantSharedStorage Enable tenant shared storage for the application
	TenantSharedStorage *bool `json:"tenantSharedStorage,omitempty"`
}

// ApplicationsApiCustomApiCreateRequest defines model for ApplicationsApiCustomApiCreateRequest.
type ApplicationsApiCustomApiCreateRequest struct {
	// Cluster The cluster you're operating on
	Cluster string `json:"cluster"`

	// EnvironmentVariables Environment variables for the application.
	// Names must start with a letter or underscore and contain only alphanumeric characters and underscores.
	// Values must not contain null characters, carriage returns, or newlines.
	EnvironmentVariables *map[string]*string `json:"environmentVariables"`

	// HardwarePackageName The name or unique identifier of the application hardware configuration to use for the application.
	HardwarePackageName string `json:"hardwarePackageName"`

	// ImageCmdOverride Optional Image CMD override allows users to specify a custom command to run in the container.
	// Must be a JSON array (e.g., ["python", "train.py"])
	ImageCmdOverride *[]string          `json:"imageCmdOverride"`
	ImageRepository  ImageRepositoryDto `json:"imageRepository"`

	// ImageUrl Image URL for the custom application.
	ImageUrl string `json:"imageUrl"`

	// Name The application name
	Name string `json:"name"`

	// PersistDirectAttachedStorage Indicates whether to persist direct attached storage (if resource pool is reserved)
	PersistDirectAttachedStorage *bool `json:"persistDirectAttachedStorage,omitempty"`

	// PersonalSharedStorage Enable personal shared storage for the application
	PersonalSharedStorage *bool `json:"personalSharedStorage,omitempty"`

	// ProxyPort Port where your service expects HTTPS traffic.
	ProxyPort *int32 `json:"proxyPort"`

	// ReadinessWatcherPort The port used for monitoring application readiness and status.
	// Common examples:
	// - 443 (JupyterLab)
	// - 22 (SSH)
	ReadinessWatcherPort *int32 `json:"readinessWatcherPort"`

	// ResourcePool The resource pool to use for the application
	ResourcePool    *string             `json:"resourcePool"`
	SecurityContext *SecurityContextDto `json:"securityContext,omitempty"`

	// TenantSharedStorage Enable tenant shared storage for the application
	TenantSharedStorage *bool `json:"tenantSharedStorage,omitempty"`
}

// ApplicationsApiDetails defines model for ApplicationsApiDetails.
type ApplicationsApiDetails struct {
	ApplicationCatalogItem *ApplicationsApiCatalogItem       `json:"applicationCatalogItem,omitempty"`
	HardwarePackage        *ApplicationsApiApplicationConfig `json:"hardwarePackage,omitempty"`
	InstanceDetails        *InstanceDetails                  `json:"instanceDetails,omitempty"`
}

// ApplicationsApiOverview defines model for ApplicationsApiOverview.
type ApplicationsApiOverview struct {
	ApplicationCatalogItemName        *string `json:"applicationCatalogItemName"`
	ApplicationCatalogItemVersionName *string `json:"applicationCatalogItemVersionName"`
	Cluster                           *string `json:"cluster"`
	CreatedBy                         *string `json:"createdBy"`
	Dns                               *string `json:"dns"`
	HardwarePackageName               *string `json:"hardwarePackageName"`
	Id                                *string `json:"id"`
	PersistedDirectAttachedStorage    *bool   `json:"persistedDirectAttachedStorage,omitempty"`
	PersonalSharedStorage             *bool   `json:"personalSharedStorage,omitempty"`
	PrivateIp                         *string `json:"privateIp"`
	PublicIp                          *string `json:"publicIp"`
	ResourcePool                      *string `json:"resourcePool"`
	SshUsername                       *string `json:"sshUsername"`
	Status                            *string `json:"status"`
	Tenant                            *string `json:"tenant"`
	TenantSharedStorage               *bool   `json:"tenantSharedStorage,omitempty"`
}

// Child defines model for Child.
type Child struct {
	Children *[]Child `json:"children"`
	Data     *Data    `json:"data,omitempty"`
}

// Data defines model for Data.
type Data struct {
	Cost      *float64   `json:"cost,omitempty"`
	EndTime   *time.Time `json:"endTime,omitempty"`
	Name      *string    `json:"name"`
	StartTime *time.Time `json:"startTime,omitempty"`
}

// ImageRepositoryDto defines model for ImageRepositoryDto.
type ImageRepositoryDto struct {
	// Hostname The registry hostname for the container repository.
	// Examples:
	// - Docker Hub: "https://index.docker.io/v1/"
	// - GitHub Container Registry: "https://ghcr.io/"
	Hostname string `json:"hostname"`

	// Password The password or access token for authentication with private repositories.
	// This is only required if the repository is private.
	Password *string `json:"password"`

	// Username The username for authentication with private repositories.
	// This is only required if the repository is private.
	Username *string `json:"username"`
}

// InstanceDetails defines model for InstanceDetails.
type InstanceDetails struct {
	Cluster *string `json:"cluster"`

	// ContainerGid Group ID (GID) for running container when not using root privileges
	ContainerGid *int32 `json:"containerGid"`

	// ContainerUid User ID (UID) for running container when not using root privileges
	ContainerUid                   *int32              `json:"containerUid"`
	CreatedBy                      *string             `json:"createdBy"`
	CreationTime                   *time.Time          `json:"creationTime,omitempty"`
	Dns                            *string             `json:"dns"`
	EnvironmentVariables           *map[string]*string `json:"environmentVariables"`
	Id                             *string             `json:"id"`
	ImageCmdOverride               *string             `json:"imageCmdOverride"`
	LastUpdated                    *time.Time          `json:"lastUpdated,omitempty"`
	PersistedDirectAttachedStorage *bool               `json:"persistedDirectAttachedStorage,omitempty"`
	PersonalSharedStorage          *bool               `json:"personalSharedStorage,omitempty"`
	PrivateIp                      *string             `json:"privateIp"`
	ProxyPort                      *int32              `json:"proxyPort"`
	PublicIp                       *string             `json:"publicIp"`
	ReadinessWatcherPort           *int32              `json:"readinessWatcherPort"`
	ResourcePool                   *string             `json:"resourcePool"`

	// RunAsRoot Run container with root privileges. When disabled, requires UID and GID.
	RunAsRoot           *bool   `json:"runAsRoot,omitempty"`
	Status              *string `json:"status"`
	StatusMessage       *string `json:"statusMessage"`
	StatusReason        *string `json:"statusReason"`
	Tenant              *string `json:"tenant"`
	TenantSharedStorage *bool   `json:"tenantSharedStorage,omitempty"`
}

// ListResultDtoOfApplicationsApiApplicationConfig defines model for ListResultDtoOfApplicationsApiApplicationConfig.
type ListResultDtoOfApplicationsApiApplicationConfig struct {
	Items *[]ApplicationsApiApplicationConfig `json:"items"`
}

// ListResultDtoOfApplicationsApiApplicationConfigAvailability defines model for ListResultDtoOfApplicationsApiApplicationConfigAvailability.
type ListResultDtoOfApplicationsApiApplicationConfigAvailability struct {
	Items *[]ApplicationsApiApplicationConfigAvailability `json:"items"`
}

// ListResultDtoOfApplicationsApiCatalogItem defines model for ListResultDtoOfApplicationsApiCatalogItem.
type ListResultDtoOfApplicationsApiCatalogItem struct {
	Items *[]ApplicationsApiCatalogItem `json:"items"`
}

// ListResultDtoOfApplicationsApiOverview defines model for ListResultDtoOfApplicationsApiOverview.
type ListResultDtoOfApplicationsApiOverview struct {
	Items *[]ApplicationsApiOverview `json:"items"`
}

// SecurityContextDto defines model for SecurityContextDto.
type SecurityContextDto struct {
	// ContainerGid Group ID (GID) for running container when not using root privileges
	ContainerGid *int32 `json:"containerGid"`

	// ContainerUid User ID (UID) for running container when not using root privileges
	ContainerUid *int32 `json:"containerUid"`

	// RunAsRoot Run container with root privileges. When disabled, requires UID and GID.
	RunAsRoot *bool `json:"runAsRoot,omitempty"`
}

// DestroyApplicationParams defines parameters for DestroyApplication.
type DestroyApplicationParams struct {
	// Id The application name
	Id string `form:"Id" json:"Id"`

	// Cluster The cluster you're operating on
	Cluster string `form:"Cluster" json:"Cluster"`
}

// GetApplicationDetailsParams defines parameters for GetApplicationDetails.
type GetApplicationDetailsParams struct {
	// Id The application name
	Id string `form:"Id" json:"Id"`

	// Cluster The cluster you're operating on
	Cluster string `form:"Cluster" json:"Cluster"`
}

// GetAvailabilityParams defines parameters for GetAvailability.
type GetAvailabilityParams struct {
	Cluster      string `form:"cluster" json:"cluster"`
	ResourcePool string `form:"resourcePool" json:"resourcePool"`
}

// CreateCatalogApplicationApplicationWildcardPlusJSONRequestBody defines body for CreateCatalogApplication for application/*+json ContentType.
type CreateCatalogApplicationApplicationWildcardPlusJSONRequestBody = ApplicationsApiCreateRequest

// CreateCatalogApplicationJSONRequestBody defines body for CreateCatalogApplication for application/json ContentType.
type CreateCatalogApplicationJSONRequestBody = ApplicationsApiCreateRequest

// CreateCatalogApplicationApplicationJSONPatchPlusJSONRequestBody defines body for CreateCatalogApplication for application/json-patch+json ContentType.
type CreateCatalogApplicationApplicationJSONPatchPlusJSONRequestBody = ApplicationsApiCreateRequest

// CreateCustomApplicationApplicationWildcardPlusJSONRequestBody defines body for CreateCustomApplication for application/*+json ContentType.
type CreateCustomApplicationApplicationWildcardPlusJSONRequestBody = ApplicationsApiCustomApiCreateRequest

// CreateCustomApplicationJSONRequestBody defines body for CreateCustomApplication for application/json ContentType.
type CreateCustomApplicationJSONRequestBody = ApplicationsApiCustomApiCreateRequest

// CreateCustomApplicationApplicationJSONPatchPlusJSONRequestBody defines body for CreateCustomApplication for application/json-patch+json ContentType.
type CreateCustomApplicationApplicationJSONPatchPlusJSONRequestBody = ApplicationsApiCustomApiCreateRequest

// StartApplicationApplicationWildcardPlusJSONRequestBody defines body for StartApplication for application/*+json ContentType.
type StartApplicationApplicationWildcardPlusJSONRequestBody = ApplicationsApiCommandRequest

// StartApplicationJSONRequestBody defines body for StartApplication for application/json ContentType.
type StartApplicationJSONRequestBody = ApplicationsApiCommandRequest

// StartApplicationApplicationJSONPatchPlusJSONRequestBody defines body for StartApplication for application/json-patch+json ContentType.
type StartApplicationApplicationJSONPatchPlusJSONRequestBody = ApplicationsApiCommandRequest

// StopApplicationApplicationWildcardPlusJSONRequestBody defines body for StopApplication for application/*+json ContentType.
type StopApplicationApplicationWildcardPlusJSONRequestBody = ApplicationsApiCommandRequest

// StopApplicationJSONRequestBody defines body for StopApplication for application/json ContentType.
type StopApplicationJSONRequestBody = ApplicationsApiCommandRequest

// StopApplicationApplicationJSONPatchPlusJSONRequestBody defines body for StopApplication for application/json-patch+json ContentType.
type StopApplicationApplicationJSONPatchPlusJSONRequestBody = ApplicationsApiCommandRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// Creates a new Client, with reasonable defaults
func NewClient() Client {
	conf := config.NewConfig()

	// Use a retryable http client and set the max retries
	// TODO: re-enable this and call client.Standard() below when we stop
	// returning incorrect 500 errors
	// client := retryablehttp.NewClient()
	// client.RetryMax = int(conf.Retries)

	// Create the client with our server, retryable client and auth intercept method
	return Client{
		Server:         conf.Server,
		Client:         http.DefaultClient,
		RequestEditors: []RequestEditorFn{conf.Auth.Intercept},
	}
}

// The interface specification for the client above.
type ClientInterface interface {

	// CreateCatalogApplicationWithBody request with any body
	CreateCatalogApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)

	// CreateCatalogApplicationWithBodyRaw request with any body
	CreateCatalogApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCatalogApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateCatalogApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateCatalogApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body CreateCatalogApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCatalogApplication(ctx context.Context, body CreateCatalogApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateCatalogApplicationRaw(ctx context.Context, body CreateCatalogApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCatalogApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body CreateCatalogApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateCatalogApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body CreateCatalogApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomApplicationWithBody request with any body
	CreateCustomApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)

	// CreateCustomApplicationWithBodyRaw request with any body
	CreateCustomApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateCustomApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateCustomApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body CreateCustomApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomApplication(ctx context.Context, body CreateCustomApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateCustomApplicationRaw(ctx context.Context, body CreateCustomApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body CreateCustomApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateCustomApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body CreateCustomApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyApplication request
	DestroyApplication(ctx context.Context, params *DestroyApplicationParams, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)

	// DestroyApplicationRaw request
	DestroyApplicationRaw(ctx context.Context, params *DestroyApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationCatalogItems request
	GetApplicationCatalogItems(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiCatalogItem, error)

	// GetApplicationCatalogItemsRaw request
	GetApplicationCatalogItemsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationDetails request
	GetApplicationDetails(ctx context.Context, params *GetApplicationDetailsParams, reqEditors ...RequestEditorFn) (*ApplicationsApiDetails, error)

	// GetApplicationDetailsRaw request
	GetApplicationDetailsRaw(ctx context.Context, params *GetApplicationDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplications request
	GetApplications(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiOverview, error)

	// GetApplicationsRaw request
	GetApplicationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailability request
	GetAvailability(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiApplicationConfigAvailability, error)

	// GetAvailabilityRaw request
	GetAvailabilityRaw(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurations request
	GetConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiApplicationConfig, error)

	// GetConfigurationsRaw request
	GetConfigurationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartApplicationWithBody request with any body
	StartApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)

	// StartApplicationWithBodyRaw request with any body
	StartApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body StartApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StartApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StartApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartApplication(ctx context.Context, body StartApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StartApplicationRaw(ctx context.Context, body StartApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StartApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StartApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StartApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopApplicationWithBody request with any body
	StopApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)

	// StopApplicationWithBodyRaw request with any body
	StopApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body StopApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StopApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StopApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopApplication(ctx context.Context, body StopApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StopApplicationRaw(ctx context.Context, body StopApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StopApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StopApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StopApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

// CreateCatalogApplicationWithBody request with arbitrary body returning *ApplicationsApiOverview
func (c *Client) CreateCatalogApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateCatalogApplicationWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateCatalogApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCatalogApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCatalogApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateCatalogApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateCatalogApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateCatalogApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body CreateCatalogApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCatalogApplicationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCatalogApplication(ctx context.Context, body CreateCatalogApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateCatalogApplicationRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateCatalogApplicationRaw(ctx context.Context, body CreateCatalogApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCatalogApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCatalogApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body CreateCatalogApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateCatalogApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateCatalogApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body CreateCatalogApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCatalogApplicationRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// CreateCustomApplicationWithBody request with arbitrary body returning *ApplicationsApiOverview
func (c *Client) CreateCustomApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateCustomApplicationWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateCustomApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateCustomApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateCustomApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateCustomApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body CreateCustomApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomApplicationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomApplication(ctx context.Context, body CreateCustomApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateCustomApplicationRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateCustomApplicationRaw(ctx context.Context, body CreateCustomApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body CreateCustomApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateCustomApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateCustomApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body CreateCustomApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomApplicationRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// DestroyApplication request returning *ApplicationsApiCommandResponse
func (c *Client) DestroyApplication(ctx context.Context, params *DestroyApplicationParams, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.DestroyApplicationRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) DestroyApplicationRaw(ctx context.Context, params *DestroyApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyApplicationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetApplicationCatalogItems request returning *ListResultDtoOfApplicationsApiCatalogItem
func (c *Client) GetApplicationCatalogItems(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiCatalogItem, error) {
	rsp, err := c.GetApplicationCatalogItemsRaw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfApplicationsApiCatalogItem](rsp)
}

func (c *Client) GetApplicationCatalogItemsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationCatalogItemsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetApplicationDetails request returning *ApplicationsApiDetails
func (c *Client) GetApplicationDetails(ctx context.Context, params *GetApplicationDetailsParams, reqEditors ...RequestEditorFn) (*ApplicationsApiDetails, error) {
	rsp, err := c.GetApplicationDetailsRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiDetails](rsp)
}

func (c *Client) GetApplicationDetailsRaw(ctx context.Context, params *GetApplicationDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetApplications request returning *ListResultDtoOfApplicationsApiOverview
func (c *Client) GetApplications(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiOverview, error) {
	rsp, err := c.GetApplicationsRaw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfApplicationsApiOverview](rsp)
}

func (c *Client) GetApplicationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetAvailability request returning *ListResultDtoOfApplicationsApiApplicationConfigAvailability
func (c *Client) GetAvailability(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiApplicationConfigAvailability, error) {
	rsp, err := c.GetAvailabilityRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfApplicationsApiApplicationConfigAvailability](rsp)
}

func (c *Client) GetAvailabilityRaw(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailabilityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetConfigurations request returning *ListResultDtoOfApplicationsApiApplicationConfig
func (c *Client) GetConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiApplicationConfig, error) {
	rsp, err := c.GetConfigurationsRaw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfApplicationsApiApplicationConfig](rsp)
}

func (c *Client) GetConfigurationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// StartApplicationWithBody request with arbitrary body returning *ApplicationsApiCommandResponse
func (c *Client) StartApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StartApplicationWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StartApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body StartApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StartApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StartApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StartApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartApplication(ctx context.Context, body StartApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StartApplicationRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StartApplicationRaw(ctx context.Context, body StartApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StartApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StartApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StartApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StartApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// StopApplicationWithBody request with arbitrary body returning *ApplicationsApiCommandResponse
func (c *Client) StopApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StopApplicationWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StopApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body StopApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StopApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StopApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StopApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopApplication(ctx context.Context, body StopApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StopApplicationRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StopApplicationRaw(ctx context.Context, body StopApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StopApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StopApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StopApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StopApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateCatalogApplicationRequestWithApplicationWildcardPlusJSONBody calls the generic CreateCatalogApplication builder with application/*+json body
func NewCreateCatalogApplicationRequestWithApplicationWildcardPlusJSONBody(server string, body CreateCatalogApplicationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCatalogApplicationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateCatalogApplicationRequest calls the generic CreateCatalogApplication builder with application/json body
func NewCreateCatalogApplicationRequest(server string, body CreateCatalogApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCatalogApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCatalogApplicationRequestWithApplicationJSONPatchPlusJSONBody calls the generic CreateCatalogApplication builder with application/json-patch+json body
func NewCreateCatalogApplicationRequestWithApplicationJSONPatchPlusJSONBody(server string, body CreateCatalogApplicationApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCatalogApplicationRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewCreateCatalogApplicationRequestWithBody generates requests for CreateCatalogApplication with any type of body
func NewCreateCatalogApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/CreateCatalogApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCustomApplicationRequestWithApplicationWildcardPlusJSONBody calls the generic CreateCustomApplication builder with application/*+json body
func NewCreateCustomApplicationRequestWithApplicationWildcardPlusJSONBody(server string, body CreateCustomApplicationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomApplicationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateCustomApplicationRequest calls the generic CreateCustomApplication builder with application/json body
func NewCreateCustomApplicationRequest(server string, body CreateCustomApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomApplicationRequestWithApplicationJSONPatchPlusJSONBody calls the generic CreateCustomApplication builder with application/json-patch+json body
func NewCreateCustomApplicationRequestWithApplicationJSONPatchPlusJSONBody(server string, body CreateCustomApplicationApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomApplicationRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewCreateCustomApplicationRequestWithBody generates requests for CreateCustomApplication with any type of body
func NewCreateCustomApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/CreateCustomApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyApplicationRequest generates requests for DestroyApplication
func NewDestroyApplicationRequest(server string, params *DestroyApplicationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/DestroyApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationCatalogItemsRequest generates requests for GetApplicationCatalogItems
func NewGetApplicationCatalogItemsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetApplicationCatalogItems")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationDetailsRequest generates requests for GetApplicationDetails
func NewGetApplicationDetailsRequest(server string, params *GetApplicationDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetApplicationDetails")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationsRequest generates requests for GetApplications
func NewGetApplicationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetApplications")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvailabilityRequest generates requests for GetAvailability
func NewGetAvailabilityRequest(server string, params *GetAvailabilityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetAvailability")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourcePool", runtime.ParamLocationQuery, params.ResourcePool); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationsRequest generates requests for GetConfigurations
func NewGetConfigurationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetConfigurations")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartApplicationRequestWithApplicationWildcardPlusJSONBody calls the generic StartApplication builder with application/*+json body
func NewStartApplicationRequestWithApplicationWildcardPlusJSONBody(server string, body StartApplicationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartApplicationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewStartApplicationRequest calls the generic StartApplication builder with application/json body
func NewStartApplicationRequest(server string, body StartApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewStartApplicationRequestWithApplicationJSONPatchPlusJSONBody calls the generic StartApplication builder with application/json-patch+json body
func NewStartApplicationRequestWithApplicationJSONPatchPlusJSONBody(server string, body StartApplicationApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartApplicationRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewStartApplicationRequestWithBody generates requests for StartApplication with any type of body
func NewStartApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/StartApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopApplicationRequestWithApplicationWildcardPlusJSONBody calls the generic StopApplication builder with application/*+json body
func NewStopApplicationRequestWithApplicationWildcardPlusJSONBody(server string, body StopApplicationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopApplicationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewStopApplicationRequest calls the generic StopApplication builder with application/json body
func NewStopApplicationRequest(server string, body StopApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewStopApplicationRequestWithApplicationJSONPatchPlusJSONBody calls the generic StopApplication builder with application/json-patch+json body
func NewStopApplicationRequestWithApplicationJSONPatchPlusJSONBody(server string, body StopApplicationApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopApplicationRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewStopApplicationRequestWithBody generates requests for StopApplication with any type of body
func NewStopApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/StopApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// Leaving client-with-responses file blank since we don't need it
