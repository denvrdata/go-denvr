// Package applications provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package applications

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/oapi-codegen/runtime"

	// "github.com/hashicorp/go-retryablehttp"

	"github.com/denvrdata/go-denvr/config"
	"github.com/denvrdata/go-denvr/response"
)

// ApplicationCatalogItemDto defines model for ApplicationCatalogItemDto.
type ApplicationCatalogItemDto struct {
	AdditionalProperties *string                             `json:"additionalProperties"`
	Description          *string                             `json:"description"`
	DisplayName          *string                             `json:"displayName"`
	Id                   *int32                              `json:"id,omitempty"`
	IsDefault            *bool                               `json:"isDefault,omitempty"`
	LogoUrl              *string                             `json:"logoUrl"`
	Name                 *string                             `json:"name"`
	Type                 *string                             `json:"type"`
	Versions             *[]ApplicationCatalogItemVersionDto `json:"versions"`
}

// ApplicationCatalogItemVersionDto defines model for ApplicationCatalogItemVersionDto.
type ApplicationCatalogItemVersionDto struct {
	AdditionalProperties     *string    `json:"additionalProperties"`
	ApplicationCatalogItemId *int32     `json:"applicationCatalogItemId"`
	Description              *string    `json:"description"`
	Id                       *int32     `json:"id,omitempty"`
	ImageLastPushDate        *time.Time `json:"imageLastPushDate"`
	ImageUrl                 *string    `json:"imageUrl"`
	Name                     *string    `json:"name"`
	Platform                 *string    `json:"platform"`
	SourceDetailsUrl         *string    `json:"sourceDetailsUrl"`
}

// ApplicationDetailsItemDto defines model for ApplicationDetailsItemDto.
type ApplicationDetailsItemDto struct {
	ApplicationCatalogItem         *ApplicationCatalogItemDto `json:"applicationCatalogItem,omitempty"`
	ApplicationCatalogItemType     *string                    `json:"applicationCatalogItemType"`
	Cluster                        *string                    `json:"cluster"`
	CommandOverride                *string                    `json:"commandOverride"`
	CreatedBy                      *string                    `json:"createdBy"`
	CreatedByTenantId              *string                    `json:"createdByTenantId"`
	CreatedByUserId                *string                    `json:"createdByUserId"`
	CreationTime                   *time.Time                 `json:"creationTime,omitempty"`
	Dns                            *string                    `json:"dns"`
	EnvironmentVariables           *map[string]*string        `json:"environmentVariables"`
	HardwarePackage                *HardwarePackageDto        `json:"hardwarePackage,omitempty"`
	ImageRepositoryHostname        *string                    `json:"imageRepositoryHostname"`
	ImageRepositoryPassword        *string                    `json:"imageRepositoryPassword"`
	ImageRepositoryUsername        *string                    `json:"imageRepositoryUsername"`
	ImageUrl                       *string                    `json:"imageUrl"`
	LastUpdated                    *time.Time                 `json:"lastUpdated,omitempty"`
	Name                           *string                    `json:"name"`
	PersistedDirectAttachedStorage *bool                      `json:"persistedDirectAttachedStorage,omitempty"`
	PersonalSharedStorage          *bool                      `json:"personalSharedStorage,omitempty"`
	Ports                          *[]int32                   `json:"ports"`
	PrivateIp                      *string                    `json:"privateIp"`
	PublicIp                       *string                    `json:"publicIp"`
	ReadinessWatcherPort           *string                    `json:"readinessWatcherPort"`
	ResourcePool                   *string                    `json:"resourcePool"`
	SshKeys                        *[]string                  `json:"sshKeys"`
	SshUsername                    *string                    `json:"sshUsername"`
	Status                         *string                    `json:"status"`
	Tenant                         *string                    `json:"tenant"`
	TenantSharedStorage            *bool                      `json:"tenantSharedStorage,omitempty"`
}

// ApplicationsApiCatalogItem defines model for ApplicationsApiCatalogItem.
type ApplicationsApiCatalogItem struct {
	ApplicationSourceDetailsUrl *string                              `json:"applicationSourceDetailsUrl"`
	Name                        *string                              `json:"name"`
	Versions                    *[]ApplicationsApiCatalogItemVersion `json:"versions"`
}

// ApplicationsApiCatalogItemVersion defines model for ApplicationsApiCatalogItemVersion.
type ApplicationsApiCatalogItemVersion struct {
	ImageLastPushDate *time.Time `json:"imageLastPushDate"`
	ImageUrl          *string    `json:"imageUrl"`
	LaunchType        *string    `json:"launchType"`
	Name              *string    `json:"name"`
	Platform          *string    `json:"platform"`
	ReleaseNotesUrl   *string    `json:"releaseNotesUrl"`
}

// ApplicationsApiCommandRequest defines model for ApplicationsApiCommandRequest.
type ApplicationsApiCommandRequest struct {
	// Cluster The cluster you're operating on
	Cluster string `json:"cluster"`

	// Id The application name
	Id string `json:"id"`
}

// ApplicationsApiCommandResponse defines model for ApplicationsApiCommandResponse.
type ApplicationsApiCommandResponse struct {
	// Cluster The cluster you're operating on
	Cluster string `json:"cluster"`

	// Id The application name
	Id string `json:"id"`
}

// ApplicationsApiCreateRequest defines model for ApplicationsApiCreateRequest.
type ApplicationsApiCreateRequest struct {
	// ApplicationCatalogItemName The name of the application catalog item.
	ApplicationCatalogItemName string `json:"applicationCatalogItemName"`

	// ApplicationCatalogItemVersion The version name of the application catalog item.
	ApplicationCatalogItemVersion string `json:"applicationCatalogItemVersion"`

	// Cluster The cluster you're operating on
	Cluster string `json:"cluster"`

	// HardwarePackageName The name or unique identifier of the hardware package to use for the application.
	HardwarePackageName string `json:"hardwarePackageName"`

	// JupyterToken An authentication token for accessing Jupyter Notebook enabled applications
	JupyterToken *string `json:"jupyterToken"`

	// Name The application name
	Name string `json:"name"`

	// PersistDirectAttachedStorage Indicates whether to persist direct attached storage (if resource pool is reserved)
	PersistDirectAttachedStorage *bool `json:"persistDirectAttachedStorage,omitempty"`

	// PersonalSharedStorage Enable personal shared storage for the application
	PersonalSharedStorage *bool `json:"personalSharedStorage,omitempty"`

	// ResourcePool The resource pool to use for the application
	ResourcePool *string `json:"resourcePool"`

	// SshKeys The SSH keys for accessing the application
	SshKeys *[]string `json:"sshKeys"`

	// TenantSharedStorage Enable tenant shared storage for the application
	TenantSharedStorage *bool `json:"tenantSharedStorage,omitempty"`
}

// ApplicationsApiDetails defines model for ApplicationsApiDetails.
type ApplicationsApiDetails struct {
	ApplicationCatalogItem *ApplicationsApiCatalogItem     `json:"applicationCatalogItem,omitempty"`
	HardwarePackage        *ApplicationsApiHardwarePackage `json:"hardwarePackage,omitempty"`
	InstanceDetails        *InstanceDetails                `json:"instanceDetails,omitempty"`
}

// ApplicationsApiHardwarePackage defines model for ApplicationsApiHardwarePackage.
type ApplicationsApiHardwarePackage struct {
	Clusters                 *[]string `json:"clusters"`
	Description              *string   `json:"description"`
	DirectAttachedStorageGb  *int32    `json:"directAttachedStorageGb"`
	GpuBrand                 *string   `json:"gpuBrand"`
	GpuCount                 *int32    `json:"gpuCount"`
	GpuName                  *string   `json:"gpuName"`
	GpuType                  *string   `json:"gpuType"`
	MemoryGb                 *int64    `json:"memoryGb"`
	Name                     *string   `json:"name"`
	OperatingSystemStorageGb *int32    `json:"operatingSystemStorageGb"`
	PricePerHour             *float64  `json:"pricePerHour"`
	VcpusCount               *int32    `json:"vcpusCount"`
}

// ApplicationsApiOverview defines model for ApplicationsApiOverview.
type ApplicationsApiOverview struct {
	ApplicationCatalogItemName        *string `json:"applicationCatalogItemName"`
	ApplicationCatalogItemVersionName *string `json:"applicationCatalogItemVersionName"`
	Cluster                           *string `json:"cluster"`
	CreatedBy                         *string `json:"createdBy"`
	Dns                               *string `json:"dns"`
	HardwarePackageName               *string `json:"hardwarePackageName"`
	Id                                *string `json:"id"`
	PersistedDirectAttachedStorage    *bool   `json:"persistedDirectAttachedStorage,omitempty"`
	PersonalSharedStorage             *bool   `json:"personalSharedStorage,omitempty"`
	PrivateIp                         *string `json:"privateIp"`
	PublicIp                          *string `json:"publicIp"`
	ResourcePool                      *string `json:"resourcePool"`
	SshUsername                       *string `json:"sshUsername"`
	Status                            *string `json:"status"`
	Tenant                            *string `json:"tenant"`
	TenantSharedStorage               *bool   `json:"tenantSharedStorage,omitempty"`
}

// Child defines model for Child.
type Child struct {
	Children *[]Child `json:"children"`
	Data     *Data    `json:"data,omitempty"`
}

// Data defines model for Data.
type Data struct {
	Cost      *float64   `json:"cost,omitempty"`
	EndTime   *time.Time `json:"endTime,omitempty"`
	Name      *string    `json:"name"`
	StartTime *time.Time `json:"startTime,omitempty"`
}

// HardwarePackageDto defines model for HardwarePackageDto.
type HardwarePackageDto struct {
	Available                  *bool    `json:"available"`
	AvailableCount             *int32   `json:"availableCount"`
	DeploymentJson             *string  `json:"deploymentJson"`
	Description                *string  `json:"description"`
	DirectAttachedStorageSize  *int32   `json:"directAttachedStorageSize"`
	DirectAttachedStorageUnit  *string  `json:"directAttachedStorageUnit"`
	DisplayName                *string  `json:"displayName"`
	GpuBrand                   *string  `json:"gpuBrand"`
	GpuCount                   *int32   `json:"gpuCount"`
	GpuName                    *string  `json:"gpuName"`
	GpuType                    *string  `json:"gpuType"`
	Id                         *int32   `json:"id,omitempty"`
	LogoUrl                    *string  `json:"logoUrl"`
	MaxCount                   *int32   `json:"maxCount"`
	MemoryByte                 *int64   `json:"memoryByte"`
	Name                       *string  `json:"name"`
	OperatingSystemStorageSize *int32   `json:"operatingSystemStorageSize"`
	OperatingSystemStorageUnit *string  `json:"operatingSystemStorageUnit"`
	PricePerHour               *float64 `json:"pricePerHour"`
	VcpusCount                 *int32   `json:"vcpusCount"`
}

// InstanceDetails defines model for InstanceDetails.
type InstanceDetails struct {
	Cluster                        *string    `json:"cluster"`
	CreatedBy                      *string    `json:"createdBy"`
	CreationTime                   *time.Time `json:"creationTime,omitempty"`
	Dns                            *string    `json:"dns"`
	Id                             *string    `json:"id"`
	LastUpdated                    *time.Time `json:"lastUpdated,omitempty"`
	PersistedDirectAttachedStorage *bool      `json:"persistedDirectAttachedStorage,omitempty"`
	PersonalSharedStorage          *bool      `json:"personalSharedStorage,omitempty"`
	PrivateIp                      *string    `json:"privateIp"`
	PublicIp                       *string    `json:"publicIp"`
	ResourcePool                   *string    `json:"resourcePool"`
	Status                         *string    `json:"status"`
	Tenant                         *string    `json:"tenant"`
	TenantSharedStorage            *bool      `json:"tenantSharedStorage,omitempty"`
}

// ListResultDtoOfApplicationsApiCatalogItem defines model for ListResultDtoOfApplicationsApiCatalogItem.
type ListResultDtoOfApplicationsApiCatalogItem struct {
	Items *[]ApplicationsApiCatalogItem `json:"items"`
}

// ListResultDtoOfApplicationsApiDetails defines model for ListResultDtoOfApplicationsApiDetails.
type ListResultDtoOfApplicationsApiDetails struct {
	Items *[]ApplicationsApiDetails `json:"items"`
}

// ListResultDtoOfHardwarePackageDto defines model for ListResultDtoOfHardwarePackageDto.
type ListResultDtoOfHardwarePackageDto struct {
	Items *[]HardwarePackageDto `json:"items"`
}

// DestroyApplicationParams defines parameters for DestroyApplication.
type DestroyApplicationParams struct {
	// Id The application name
	Id string `form:"Id" json:"Id"`

	// Cluster The cluster you're operating on
	Cluster string `form:"Cluster" json:"Cluster"`
}

// GetApplicationDetailsParams defines parameters for GetApplicationDetails.
type GetApplicationDetailsParams struct {
	// Id The application name
	Id string `form:"Id" json:"Id"`

	// Cluster The cluster you're operating on
	Cluster string `form:"Cluster" json:"Cluster"`
}

// GetAvailabilityParams defines parameters for GetAvailability.
type GetAvailabilityParams struct {
	Cluster      string `form:"cluster" json:"cluster"`
	ResourcePool string `form:"resourcePool" json:"resourcePool"`
}

// CreateApplicationApplicationWildcardPlusJSONRequestBody defines body for CreateApplication for application/*+json ContentType.
type CreateApplicationApplicationWildcardPlusJSONRequestBody = ApplicationsApiCreateRequest

// CreateApplicationJSONRequestBody defines body for CreateApplication for application/json ContentType.
type CreateApplicationJSONRequestBody = ApplicationsApiCreateRequest

// CreateApplicationApplicationJSONPatchPlusJSONRequestBody defines body for CreateApplication for application/json-patch+json ContentType.
type CreateApplicationApplicationJSONPatchPlusJSONRequestBody = ApplicationsApiCreateRequest

// StartApplicationApplicationWildcardPlusJSONRequestBody defines body for StartApplication for application/*+json ContentType.
type StartApplicationApplicationWildcardPlusJSONRequestBody = ApplicationsApiCommandRequest

// StartApplicationJSONRequestBody defines body for StartApplication for application/json ContentType.
type StartApplicationJSONRequestBody = ApplicationsApiCommandRequest

// StartApplicationApplicationJSONPatchPlusJSONRequestBody defines body for StartApplication for application/json-patch+json ContentType.
type StartApplicationApplicationJSONPatchPlusJSONRequestBody = ApplicationsApiCommandRequest

// StopApplicationApplicationWildcardPlusJSONRequestBody defines body for StopApplication for application/*+json ContentType.
type StopApplicationApplicationWildcardPlusJSONRequestBody = ApplicationsApiCommandRequest

// StopApplicationJSONRequestBody defines body for StopApplication for application/json ContentType.
type StopApplicationJSONRequestBody = ApplicationsApiCommandRequest

// StopApplicationApplicationJSONPatchPlusJSONRequestBody defines body for StopApplication for application/json-patch+json ContentType.
type StopApplicationApplicationJSONPatchPlusJSONRequestBody = ApplicationsApiCommandRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// Creates a new Client, with reasonable defaults
func NewClient() Client {
	conf := config.NewConfig()

	// Use a retryable http client and set the max retries
	// TODO: re-enable this and call client.Standard() below when we stop
	// returning incorrect 500 errors
	// client := retryablehttp.NewClient()
	// client.RetryMax = int(conf.Retries)

	// Create the client with our server, retryable client and auth intercept method
	return Client{
		Server:         conf.Server,
		Client:         http.DefaultClient,
		RequestEditors: []RequestEditorFn{conf.Auth.Intercept},
	}
}

// The interface specification for the client above.
type ClientInterface interface {

	// CreateApplicationWithBody request with any body
	CreateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)

	// CreateApplicationWithBodyRaw request with any body
	CreateApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body CreateApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApplication(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateApplicationRaw(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body CreateApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error)
	CreateApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body CreateApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyApplication request
	DestroyApplication(ctx context.Context, params *DestroyApplicationParams, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)

	// DestroyApplicationRaw request
	DestroyApplicationRaw(ctx context.Context, params *DestroyApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationCatalogItems request
	GetApplicationCatalogItems(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiCatalogItem, error)

	// GetApplicationCatalogItemsRaw request
	GetApplicationCatalogItemsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationDetails request
	GetApplicationDetails(ctx context.Context, params *GetApplicationDetailsParams, reqEditors ...RequestEditorFn) (*ApplicationDetailsItemDto, error)

	// GetApplicationDetailsRaw request
	GetApplicationDetailsRaw(ctx context.Context, params *GetApplicationDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplications request
	GetApplications(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiDetails, error)

	// GetApplicationsRaw request
	GetApplicationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailability request
	GetAvailability(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*ListResultDtoOfHardwarePackageDto, error)

	// GetAvailabilityRaw request
	GetAvailabilityRaw(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurations request
	GetConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfHardwarePackageDto, error)

	// GetConfigurationsRaw request
	GetConfigurationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartApplicationWithBody request with any body
	StartApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)

	// StartApplicationWithBodyRaw request with any body
	StartApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body StartApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StartApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StartApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartApplication(ctx context.Context, body StartApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StartApplicationRaw(ctx context.Context, body StartApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StartApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StartApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StartApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopApplicationWithBody request with any body
	StopApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)

	// StopApplicationWithBodyRaw request with any body
	StopApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body StopApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StopApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StopApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopApplication(ctx context.Context, body StopApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StopApplicationRaw(ctx context.Context, body StopApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StopApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error)
	StopApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StopApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

// CreateApplicationWithBody request with arbitrary body returning *ApplicationsApiOverview
func (c *Client) CreateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateApplicationWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body CreateApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplication(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateApplicationRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateApplicationRaw(ctx context.Context, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body CreateApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiOverview, error) {
	rsp, err := c.CreateApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiOverview](rsp)
}

func (c *Client) CreateApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body CreateApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// DestroyApplication request returning *ApplicationsApiCommandResponse
func (c *Client) DestroyApplication(ctx context.Context, params *DestroyApplicationParams, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.DestroyApplicationRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) DestroyApplicationRaw(ctx context.Context, params *DestroyApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyApplicationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetApplicationCatalogItems request returning *ListResultDtoOfApplicationsApiCatalogItem
func (c *Client) GetApplicationCatalogItems(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiCatalogItem, error) {
	rsp, err := c.GetApplicationCatalogItemsRaw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfApplicationsApiCatalogItem](rsp)
}

func (c *Client) GetApplicationCatalogItemsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationCatalogItemsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetApplicationDetails request returning *ApplicationDetailsItemDto
func (c *Client) GetApplicationDetails(ctx context.Context, params *GetApplicationDetailsParams, reqEditors ...RequestEditorFn) (*ApplicationDetailsItemDto, error) {
	rsp, err := c.GetApplicationDetailsRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationDetailsItemDto](rsp)
}

func (c *Client) GetApplicationDetailsRaw(ctx context.Context, params *GetApplicationDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetApplications request returning *ListResultDtoOfApplicationsApiDetails
func (c *Client) GetApplications(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfApplicationsApiDetails, error) {
	rsp, err := c.GetApplicationsRaw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfApplicationsApiDetails](rsp)
}

func (c *Client) GetApplicationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetAvailability request returning *ListResultDtoOfHardwarePackageDto
func (c *Client) GetAvailability(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*ListResultDtoOfHardwarePackageDto, error) {
	rsp, err := c.GetAvailabilityRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfHardwarePackageDto](rsp)
}

func (c *Client) GetAvailabilityRaw(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailabilityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetConfigurations request returning *ListResultDtoOfHardwarePackageDto
func (c *Client) GetConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfHardwarePackageDto, error) {
	rsp, err := c.GetConfigurationsRaw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfHardwarePackageDto](rsp)
}

func (c *Client) GetConfigurationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// StartApplicationWithBody request with arbitrary body returning *ApplicationsApiCommandResponse
func (c *Client) StartApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StartApplicationWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StartApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body StartApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StartApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StartApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StartApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartApplication(ctx context.Context, body StartApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StartApplicationRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StartApplicationRaw(ctx context.Context, body StartApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StartApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StartApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StartApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StartApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartApplicationRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// StopApplicationWithBody request with arbitrary body returning *ApplicationsApiCommandResponse
func (c *Client) StopApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StopApplicationWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StopApplicationWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopApplicationWithApplicationWildcardPlusJSONBody(ctx context.Context, body StopApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StopApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StopApplicationWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StopApplicationApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopApplication(ctx context.Context, body StopApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StopApplicationRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StopApplicationRaw(ctx context.Context, body StopApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopApplicationWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StopApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplicationsApiCommandResponse, error) {
	rsp, err := c.StopApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ApplicationsApiCommandResponse](rsp)
}

func (c *Client) StopApplicationWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StopApplicationApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopApplicationRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateApplicationRequestWithApplicationWildcardPlusJSONBody calls the generic CreateApplication builder with application/*+json body
func NewCreateApplicationRequestWithApplicationWildcardPlusJSONBody(server string, body CreateApplicationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApplicationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateApplicationRequest calls the generic CreateApplication builder with application/json body
func NewCreateApplicationRequest(server string, body CreateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateApplicationRequestWithApplicationJSONPatchPlusJSONBody calls the generic CreateApplication builder with application/json-patch+json body
func NewCreateApplicationRequestWithApplicationJSONPatchPlusJSONBody(server string, body CreateApplicationApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApplicationRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewCreateApplicationRequestWithBody generates requests for CreateApplication with any type of body
func NewCreateApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/CreateApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyApplicationRequest generates requests for DestroyApplication
func NewDestroyApplicationRequest(server string, params *DestroyApplicationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/DestroyApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationCatalogItemsRequest generates requests for GetApplicationCatalogItems
func NewGetApplicationCatalogItemsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetApplicationCatalogItems")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationDetailsRequest generates requests for GetApplicationDetails
func NewGetApplicationDetailsRequest(server string, params *GetApplicationDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetApplicationDetails")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationsRequest generates requests for GetApplications
func NewGetApplicationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetApplications")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvailabilityRequest generates requests for GetAvailability
func NewGetAvailabilityRequest(server string, params *GetAvailabilityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetAvailability")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourcePool", runtime.ParamLocationQuery, params.ResourcePool); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationsRequest generates requests for GetConfigurations
func NewGetConfigurationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/GetConfigurations")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartApplicationRequestWithApplicationWildcardPlusJSONBody calls the generic StartApplication builder with application/*+json body
func NewStartApplicationRequestWithApplicationWildcardPlusJSONBody(server string, body StartApplicationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartApplicationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewStartApplicationRequest calls the generic StartApplication builder with application/json body
func NewStartApplicationRequest(server string, body StartApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewStartApplicationRequestWithApplicationJSONPatchPlusJSONBody calls the generic StartApplication builder with application/json-patch+json body
func NewStartApplicationRequestWithApplicationJSONPatchPlusJSONBody(server string, body StartApplicationApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartApplicationRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewStartApplicationRequestWithBody generates requests for StartApplication with any type of body
func NewStartApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/StartApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopApplicationRequestWithApplicationWildcardPlusJSONBody calls the generic StopApplication builder with application/*+json body
func NewStopApplicationRequestWithApplicationWildcardPlusJSONBody(server string, body StopApplicationApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopApplicationRequestWithBody(server, "application/*+json", bodyReader)
}

// NewStopApplicationRequest calls the generic StopApplication builder with application/json body
func NewStopApplicationRequest(server string, body StopApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewStopApplicationRequestWithApplicationJSONPatchPlusJSONBody calls the generic StopApplication builder with application/json-patch+json body
func NewStopApplicationRequestWithApplicationJSONPatchPlusJSONBody(server string, body StopApplicationApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopApplicationRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewStopApplicationRequestWithBody generates requests for StopApplication with any type of body
func NewStopApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/applications/StopApplication")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// Leaving client-with-responses file blank since we don't need it
