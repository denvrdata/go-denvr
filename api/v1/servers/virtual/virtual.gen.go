// Package virtual provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package virtual

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/oapi-codegen/runtime"

	// "github.com/hashicorp/go-retryablehttp"

	"github.com/denvrdata/go-denvr/config"
	"github.com/denvrdata/go-denvr/response"
)

// Child defines model for Child.
type Child struct {
	Children *[]Child `json:"children"`
	Data     *Data    `json:"data,omitempty"`
}

// CreateVirtualServerInput defines model for CreateVirtualServerInput.
type CreateVirtualServerInput struct {
	// Cluster Cluster to be used. For possible values, refer to the otput of api/v1/clusters/GetAll"/>
	Cluster string `json:"cluster"`

	// Configuration Name of the configuration to be used. For possible values, refer to the otput of api/v1/servers/virtual/GetConfigurations, field 'name' DenvrDashboard.Servers.Dtos.ServerConfiguration.Name
	Configuration string `json:"configuration"`

	// DirectStorageMountPath Direct attached storage mount path.
	DirectStorageMountPath *string `json:"directStorageMountPath"`

	// Name Name of virtual server to be created. If not provided, name will be auto-generated.
	Name *string `json:"name"`

	// OperatingSystemImage Name of the Operating System image to be used.
	OperatingSystemImage *string `json:"operatingSystemImage"`

	// PersistStorage Whether direct attached storage should be persistant or ephemeral.
	PersistStorage *bool `json:"persistStorage,omitempty"`

	// PersonalStorageMountPath Personal storage file system mount path.
	PersonalStorageMountPath *string `json:"personalStorageMountPath"`

	// RootDiskSize Size of root disk to be created (Gi).
	RootDiskSize *int32 `json:"rootDiskSize,omitempty"`

	// Rpool Name of the pool to be used. If not provided, first pool assigned to a tenant will be used. In case of no pool assigned, 'on-demand' will be used.
	Rpool *string `json:"rpool"`

	// SnapshotName Snapshot name.
	SnapshotName *string  `json:"snapshotName"`
	SshKeys      []string `json:"ssh_keys"`

	// TenantSharedAdditionalStorage Tenant shared storage file system mount path.
	TenantSharedAdditionalStorage *string `json:"tenantSharedAdditionalStorage"`

	// Vpc Name of the VPC to be used. Usually this will match the tenant name.
	Vpc string `json:"vpc"`
}

// Data defines model for Data.
type Data struct {
	Cost      *float64   `json:"cost,omitempty"`
	EndTime   *time.Time `json:"endTime,omitempty"`
	Name      *string    `json:"name"`
	StartTime *time.Time `json:"startTime,omitempty"`
}

// ListResultDtoOfServerAvailability defines model for ListResultDtoOfServerAvailability.
type ListResultDtoOfServerAvailability struct {
	Items *[]ServerAvailability `json:"items"`
}

// ListResultDtoOfServerConfiguration defines model for ListResultDtoOfServerConfiguration.
type ListResultDtoOfServerConfiguration struct {
	Items *[]ServerConfiguration `json:"items"`
}

// ListResultDtoOfVirtualServerDetailsItem defines model for ListResultDtoOfVirtualServerDetailsItem.
type ListResultDtoOfVirtualServerDetailsItem struct {
	Items *[]VirtualServerDetailsItem `json:"items"`
}

// ServerAvailability defines model for ServerAvailability.
type ServerAvailability struct {
	Available     *bool   `json:"available,omitempty"`
	Cluster       *string `json:"cluster"`
	Configuration *string `json:"configuration"`

	// Count number of servers that can be created with this configuration.
	Count *int32 `json:"count,omitempty"`

	// MaxCount maximum number of servers that can be created with this configuration. 0 if resource pool is on-demand.
	MaxCount *int32   `json:"maxCount,omitempty"`
	Price    *float64 `json:"price,omitempty"`
	Rpool    *string  `json:"rpool"`
	// Deprecated:
	Type *string `json:"type"`
}

// ServerCommandInput defines model for ServerCommandInput.
type ServerCommandInput struct {
	// Cluster The cluster you're operating on
	Cluster string `json:"cluster"`

	// Id The virtual machine id
	Id string `json:"id"`

	// Namespace The namespace/vpc where the virtual machine lives. Default one is same as tenant name.
	Namespace string `json:"namespace"`
}

// ServerConfiguration defines model for ServerConfiguration.
type ServerConfiguration struct {
	Brand          *string   `json:"brand"`
	BrandFamily    *string   `json:"brand_family"`
	Clusters       *[]string `json:"clusters"`
	ComputeNetwork *string   `json:"compute_network"`
	Description    *string   `json:"description"`
	// Deprecated:
	GpuBrand *string `json:"gpu_brand"`
	// Deprecated:
	GpuFamily *string `json:"gpu_family"`
	// Deprecated:
	GpuName *string `json:"gpu_name"`
	// Deprecated:
	GpuType       *string `json:"gpu_type"`
	Gpus          *int32  `json:"gpus,omitempty"`
	Id            *int32  `json:"id,omitempty"`
	IsGpuPlatform *bool   `json:"is_gpu_platform,omitempty"`
	Memory        *int64  `json:"memory,omitempty"`
	Name          *string `json:"name"`
	// Deprecated:
	OsType *string `json:"os_type"`
	// Deprecated:
	OsVersion        *string  `json:"os_version"`
	Price            *float64 `json:"price,omitempty"`
	Storage          *int64   `json:"storage,omitempty"`
	TextName         *string  `json:"text_name"`
	Type             *string  `json:"type"`
	UserFriendlyName *string  `json:"user_friendly_name"`
	Vcpus            *int32   `json:"vcpus,omitempty"`
}

// VirtualServerDetailsItem defines model for VirtualServerDetailsItem.
type VirtualServerDetailsItem struct {
	// Cluster The cluster where the VM is allocated
	Cluster *string `json:"cluster"`

	// Configuration A VM configuration ID
	Configuration                  *string `json:"configuration"`
	DirectAttachedStoragePersisted *bool   `json:"directAttachedStoragePersisted,omitempty"`

	// GpuType The specific host GPU type
	GpuType *string `json:"gpu_type"`

	// Gpus Number of GPUs attached to the VM
	Gpus *int32 `json:"gpus"`

	// Id The name of the virtual machine
	Id *string `json:"id"`

	// Image Name of the VM image used
	Image *string `json:"image"`

	// Ip The public IP address of the VM
	Ip *string `json:"ip"`

	// Memory Amount of system memory available in GB
	Memory    *int64  `json:"memory"`
	Namespace *string `json:"namespace"`

	// PrivateIp The private IP address of the VM
	PrivateIp    *string `json:"privateIp"`
	RootDiskSize *string `json:"rootDiskSize"`

	// Rpool Resource pool where the VM has been created
	Rpool *string `json:"rpool"`

	// Status The status of the VM (e.g. 'PLANNED', 'PENDING' 'PENDING_RESOURCES', 'PENDING_READINESS', 'ONLINE', 'OFFLINE')
	Status *string `json:"status"`

	// Storage The amount of storage attached to the VM in GB
	Storage     *int64  `json:"storage"`
	StorageType *string `json:"storageType"`

	// TenancyName Name of the tenant where the VM has been created
	TenancyName *string `json:"tenancy_name"`

	// Username The user that creatd the vm
	Username *string `json:"username"`

	// Vcpus Number of vCPUs available to the VM
	Vcpus *int32 `json:"vcpus"`
}

// DestroyServerParams defines parameters for DestroyServer.
type DestroyServerParams struct {
	// Id The virtual machine id
	Id string `form:"Id" json:"Id"`

	// Namespace The namespace/vpc where the virtual machine lives. Default one is same as tenant name.
	Namespace string `form:"Namespace" json:"Namespace"`

	// Cluster The cluster you're operating on
	Cluster string `form:"Cluster" json:"Cluster"`
}

// GetAvailabilityParams defines parameters for GetAvailability.
type GetAvailabilityParams struct {
	Cluster      string  `form:"cluster" json:"cluster"`
	ResourcePool *string `form:"resourcePool,omitempty" json:"resourcePool,omitempty"`

	// ReportNodes controls if Count and MaxCount is calculated and returned in the response. If they are not needed, use 'false' to improve response time of the endpoint.
	ReportNodes *bool `form:"reportNodes,omitempty" json:"reportNodes,omitempty"`
}

// GetServerParams defines parameters for GetServer.
type GetServerParams struct {
	// Id The virtual machine id
	Id string `form:"Id" json:"Id"`

	// Namespace The namespace/vpc where the virtual machine lives. Default one is same as tenant name.
	Namespace string `form:"Namespace" json:"Namespace"`

	// Cluster The cluster you're operating on
	Cluster string `form:"Cluster" json:"Cluster"`
}

// GetServersParams defines parameters for GetServers.
type GetServersParams struct {
	Cluster *string `form:"Cluster,omitempty" json:"Cluster,omitempty"`
}

// CreateServerApplicationWildcardPlusJSONRequestBody defines body for CreateServer for application/*+json ContentType.
type CreateServerApplicationWildcardPlusJSONRequestBody = CreateVirtualServerInput

// CreateServerJSONRequestBody defines body for CreateServer for application/json ContentType.
type CreateServerJSONRequestBody = CreateVirtualServerInput

// CreateServerApplicationJSONPatchPlusJSONRequestBody defines body for CreateServer for application/json-patch+json ContentType.
type CreateServerApplicationJSONPatchPlusJSONRequestBody = CreateVirtualServerInput

// StartServerApplicationWildcardPlusJSONRequestBody defines body for StartServer for application/*+json ContentType.
type StartServerApplicationWildcardPlusJSONRequestBody = ServerCommandInput

// StartServerJSONRequestBody defines body for StartServer for application/json ContentType.
type StartServerJSONRequestBody = ServerCommandInput

// StartServerApplicationJSONPatchPlusJSONRequestBody defines body for StartServer for application/json-patch+json ContentType.
type StartServerApplicationJSONPatchPlusJSONRequestBody = ServerCommandInput

// StopServerApplicationWildcardPlusJSONRequestBody defines body for StopServer for application/*+json ContentType.
type StopServerApplicationWildcardPlusJSONRequestBody = ServerCommandInput

// StopServerJSONRequestBody defines body for StopServer for application/json ContentType.
type StopServerJSONRequestBody = ServerCommandInput

// StopServerApplicationJSONPatchPlusJSONRequestBody defines body for StopServer for application/json-patch+json ContentType.
type StopServerApplicationJSONPatchPlusJSONRequestBody = ServerCommandInput

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// Creates a new Client, with reasonable defaults
func NewClient() Client {
	conf := config.NewConfig()

	// Use a retryable http client and set the max retries
	// TODO: re-enable this and call client.Standard() below when we stop
	// returning incorrect 500 errors
	// client := retryablehttp.NewClient()
	// client.RetryMax = int(conf.Retries)

	// Create the client with our server, retryable client and auth intercept method
	return Client{
		Server:         conf.Server,
		Client:         http.DefaultClient,
		RequestEditors: []RequestEditorFn{conf.Auth.Intercept},
	}
}

// The interface specification for the client above.
type ClientInterface interface {

	// CreateServerWithBody request with any body
	CreateServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)

	// CreateServerWithBodyRaw request with any body
	CreateServerWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	CreateServerWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body CreateServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServer(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	CreateServerRaw(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body CreateServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	CreateServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body CreateServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyServer request
	DestroyServer(ctx context.Context, params *DestroyServerParams, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)

	// DestroyServerRaw request
	DestroyServerRaw(ctx context.Context, params *DestroyServerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailability request
	GetAvailability(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*ListResultDtoOfServerAvailability, error)

	// GetAvailabilityRaw request
	GetAvailabilityRaw(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurations request
	GetConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfServerConfiguration, error)

	// GetConfigurationsRaw request
	GetConfigurationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServer request
	GetServer(ctx context.Context, params *GetServerParams, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)

	// GetServerRaw request
	GetServerRaw(ctx context.Context, params *GetServerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServers request
	GetServers(ctx context.Context, params *GetServersParams, reqEditors ...RequestEditorFn) (*ListResultDtoOfVirtualServerDetailsItem, error)

	// GetServersRaw request
	GetServersRaw(ctx context.Context, params *GetServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartServerWithBody request with any body
	StartServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)

	// StartServerWithBodyRaw request with any body
	StartServerWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartServerWithApplicationWildcardPlusJSONBody(ctx context.Context, body StartServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	StartServerWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StartServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartServer(ctx context.Context, body StartServerJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	StartServerRaw(ctx context.Context, body StartServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartServerWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StartServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	StartServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StartServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopServerWithBody request with any body
	StopServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)

	// StopServerWithBodyRaw request with any body
	StopServerWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopServerWithApplicationWildcardPlusJSONBody(ctx context.Context, body StopServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	StopServerWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StopServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopServer(ctx context.Context, body StopServerJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	StopServerRaw(ctx context.Context, body StopServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopServerWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StopServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error)
	StopServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StopServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

// CreateServerWithBody request with arbitrary body returning *VirtualServerDetailsItem
func (c *Client) CreateServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.CreateServerWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) CreateServerWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerWithApplicationWildcardPlusJSONBody(ctx context.Context, body CreateServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.CreateServerWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) CreateServerWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body CreateServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServer(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.CreateServerRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) CreateServerRaw(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body CreateServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.CreateServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) CreateServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body CreateServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// DestroyServer request returning *VirtualServerDetailsItem
func (c *Client) DestroyServer(ctx context.Context, params *DestroyServerParams, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.DestroyServerRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) DestroyServerRaw(ctx context.Context, params *DestroyServerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyServerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetAvailability request returning *ListResultDtoOfServerAvailability
func (c *Client) GetAvailability(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*ListResultDtoOfServerAvailability, error) {
	rsp, err := c.GetAvailabilityRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfServerAvailability](rsp)
}

func (c *Client) GetAvailabilityRaw(ctx context.Context, params *GetAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailabilityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetConfigurations request returning *ListResultDtoOfServerConfiguration
func (c *Client) GetConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*ListResultDtoOfServerConfiguration, error) {
	rsp, err := c.GetConfigurationsRaw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfServerConfiguration](rsp)
}

func (c *Client) GetConfigurationsRaw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetServer request returning *VirtualServerDetailsItem
func (c *Client) GetServer(ctx context.Context, params *GetServerParams, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.GetServerRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) GetServerRaw(ctx context.Context, params *GetServerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// GetServers request returning *ListResultDtoOfVirtualServerDetailsItem
func (c *Client) GetServers(ctx context.Context, params *GetServersParams, reqEditors ...RequestEditorFn) (*ListResultDtoOfVirtualServerDetailsItem, error) {
	rsp, err := c.GetServersRaw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[ListResultDtoOfVirtualServerDetailsItem](rsp)
}

func (c *Client) GetServersRaw(ctx context.Context, params *GetServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// StartServerWithBody request with arbitrary body returning *VirtualServerDetailsItem
func (c *Client) StartServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.StartServerWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) StartServerWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartServerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartServerWithApplicationWildcardPlusJSONBody(ctx context.Context, body StartServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.StartServerWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) StartServerWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StartServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartServerRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartServer(ctx context.Context, body StartServerJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.StartServerRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) StartServerRaw(ctx context.Context, body StartServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartServerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartServerWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StartServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.StartServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) StartServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StartServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartServerRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// StopServerWithBody request with arbitrary body returning *VirtualServerDetailsItem
func (c *Client) StopServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.StopServerWithBodyRaw(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) StopServerWithBodyRaw(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopServerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopServerWithApplicationWildcardPlusJSONBody(ctx context.Context, body StopServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.StopServerWithApplicationWildcardPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) StopServerWithApplicationWildcardPlusJSONBodyRaw(ctx context.Context, body StopServerApplicationWildcardPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopServerRequestWithApplicationWildcardPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopServer(ctx context.Context, body StopServerJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.StopServerRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) StopServerRaw(ctx context.Context, body StopServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopServerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopServerWithApplicationJSONPatchPlusJSONBody(ctx context.Context, body StopServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*VirtualServerDetailsItem, error) {
	rsp, err := c.StopServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return response.ParseResponse[VirtualServerDetailsItem](rsp)
}

func (c *Client) StopServerWithApplicationJSONPatchPlusJSONBodyRaw(ctx context.Context, body StopServerApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopServerRequestWithApplicationJSONPatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateServerRequestWithApplicationWildcardPlusJSONBody calls the generic CreateServer builder with application/*+json body
func NewCreateServerRequestWithApplicationWildcardPlusJSONBody(server string, body CreateServerApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerRequestWithBody(server, "application/*+json", bodyReader)
}

// NewCreateServerRequest calls the generic CreateServer builder with application/json body
func NewCreateServerRequest(server string, body CreateServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateServerRequestWithApplicationJSONPatchPlusJSONBody calls the generic CreateServer builder with application/json-patch+json body
func NewCreateServerRequestWithApplicationJSONPatchPlusJSONBody(server string, body CreateServerApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewCreateServerRequestWithBody generates requests for CreateServer with any type of body
func NewCreateServerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/virtual/CreateServer")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyServerRequest generates requests for DestroyServer
func NewDestroyServerRequest(server string, params *DestroyServerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/virtual/DestroyServer")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Namespace", runtime.ParamLocationQuery, params.Namespace); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvailabilityRequest generates requests for GetAvailability
func NewGetAvailabilityRequest(server string, params *GetAvailabilityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/virtual/GetAvailability")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResourcePool != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resourcePool", runtime.ParamLocationQuery, *params.ResourcePool); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportNodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportNodes", runtime.ParamLocationQuery, *params.ReportNodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationsRequest generates requests for GetConfigurations
func NewGetConfigurationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/virtual/GetConfigurations")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerRequest generates requests for GetServer
func NewGetServerRequest(server string, params *GetServerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/virtual/GetServer")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Namespace", runtime.ParamLocationQuery, params.Namespace); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Cluster", runtime.ParamLocationQuery, params.Cluster); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServersRequest generates requests for GetServers
func NewGetServersRequest(server string, params *GetServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/virtual/GetServers")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "Cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartServerRequestWithApplicationWildcardPlusJSONBody calls the generic StartServer builder with application/*+json body
func NewStartServerRequestWithApplicationWildcardPlusJSONBody(server string, body StartServerApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartServerRequestWithBody(server, "application/*+json", bodyReader)
}

// NewStartServerRequest calls the generic StartServer builder with application/json body
func NewStartServerRequest(server string, body StartServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartServerRequestWithBody(server, "application/json", bodyReader)
}

// NewStartServerRequestWithApplicationJSONPatchPlusJSONBody calls the generic StartServer builder with application/json-patch+json body
func NewStartServerRequestWithApplicationJSONPatchPlusJSONBody(server string, body StartServerApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartServerRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewStartServerRequestWithBody generates requests for StartServer with any type of body
func NewStartServerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/virtual/StartServer")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopServerRequestWithApplicationWildcardPlusJSONBody calls the generic StopServer builder with application/*+json body
func NewStopServerRequestWithApplicationWildcardPlusJSONBody(server string, body StopServerApplicationWildcardPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopServerRequestWithBody(server, "application/*+json", bodyReader)
}

// NewStopServerRequest calls the generic StopServer builder with application/json body
func NewStopServerRequest(server string, body StopServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopServerRequestWithBody(server, "application/json", bodyReader)
}

// NewStopServerRequestWithApplicationJSONPatchPlusJSONBody calls the generic StopServer builder with application/json-patch+json body
func NewStopServerRequestWithApplicationJSONPatchPlusJSONBody(server string, body StopServerApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopServerRequestWithBody(server, "application/json-patch+json", bodyReader)
}

// NewStopServerRequestWithBody generates requests for StopServer with any type of body
func NewStopServerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/servers/virtual/StopServer")
	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// Leaving client-with-responses file blank since we don't need it
